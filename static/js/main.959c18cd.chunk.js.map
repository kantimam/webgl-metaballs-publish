{"version":3,"sources":["metaballs/util.ts","metaballs/Orb.ts","metaballs/metaballsLogic.ts","metaballs/shaders.ts","metaballs/index.tsx","App.js","serviceWorker.js","index.js"],"names":["checkCollisionRect","orb","top","right","bottom","left","onCollisionX","onCollisionY","positionX","lastCollision","positionY","randomInRange","start","end","Math","floor","random","createShader","gl","type","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","log","getShaderInfoLog","deleteShader","createProgram","vertexShader","fragmentShader","program","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","Orb","size","colorR","colorG","colorB","moveX","moveY","this","min","max","MetaBalls","canvasRef","containerRef","deflectMovement","shiftColor","orbSettings","orbCount","orbArray","reflectX","reflectY","shaderProgram","renderLoop","lastContainerWidth","lastContainerHeight","containIn","setDynamicLength","shaderString","length","replace","String","setPositionInBounds","forEach","e","clientWidth","offsetLeft","clientHeight","offsetTop","u_orbDataFromArray","u_orbDataArray","i","push","updateOrbs","updatePosition","render","positionLocation","getAttribLocation","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","useProgram","uResolutionLocation","getUniformLocation","uOrbArrayLocation","uDistModifierLocation","uniform1f","uniform2fv","enableVertexAttribArray","FLOAT","vertexAttribPointer","viewport","width","height","clearColor","clear","COLOR_BUFFER_BIT","window","onresize","setCanvasDim","drawingBufferWidth","drawingBufferHeight","drawLoop","uniform1fv","drawArrays","TRIANGLES","requestAnimationFrame","destroy","cancelAnimationFrame","getContext","deflectMovementX","deflectMovementY","createOrbs","fragWithDynamicLength","vertexShaderSource","fragmentShaderSource","VERTEX_SHADER","FRAGMENT_SHADER","createShaderProgram","orbConfig","index","posX","posY","defaultInnerContainer","className","style","orbData","innerContainer","children","childContainerFlex","useRef","innerRef","useLayoutEffect","metaball","current","MetaBallsRenderer","create","id","position","overflow","ref","display","flexDirection","React","flex","App","Boolean","location","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.959c18cd.chunk.js","sourcesContent":["import Orb from './Orb'\r\n\r\n\r\n\r\nexport const checkCollisionRect=(orb: Orb, top: number, right: number, bottom: number, left: number, onCollisionX: Function, onCollisionY: Function):void=>{\r\n    if(orb.positionX>right && orb.lastCollision!=2) {orb.lastCollision=2; onCollisionX(orb)};\r\n    if(orb.positionX<left && orb.lastCollision!=4) {orb.lastCollision=4; onCollisionX(orb)};\r\n\r\n    if(orb.positionY>bottom && orb.lastCollision!=3) {orb.lastCollision=3; onCollisionY(orb)};\r\n    if(orb.positionY<top && orb.lastCollision!=1) {orb.lastCollision=1; onCollisionY(orb)};\r\n}\r\n\r\nexport const switchColor=(orb: Orb)=>{\r\n    orb.colorR=(orb.colorR+randomInRange(0,50))%255;\r\n    orb.colorG=(orb.colorG+randomInRange(0,50))%255;\r\n    orb.colorB=(orb.colorB+randomInRange(0,50))%255;\r\n}\r\n\r\nexport const randomInRange=(start: number, end: number): number=>{\r\n    return Math.floor(Math.random()*(end-start))+start;\r\n}\r\n\r\nexport const createShaderProgram = (gl: any, vertexShaderSource: string, fragmentShaderSource: string):WebGLProgram => {\r\n\r\n    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource)\r\n    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource)\r\n\r\n    const program = createProgram(gl, vertexShader, fragmentShader);\r\n\r\n    return program\r\n}\r\n\r\n\r\nconst createShader = (gl: any, type: number, source: any) => {\r\n    const shader = gl.createShader(type);\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n    const succes = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n    if (succes) {\r\n        return shader;\r\n    }\r\n\r\n    console.log(gl.getShaderInfoLog(shader));\r\n    gl.deleteShader(shader);\r\n}\r\n\r\nconst createProgram = (gl: any, vertexShader: any, fragmentShader: any) => {\r\n    const program = gl.createProgram();\r\n    gl.attachShader(program, vertexShader);\r\n    gl.attachShader(program, fragmentShader);\r\n    gl.linkProgram(program);\r\n    const success = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n    if (success) {\r\n        return program;\r\n    }\r\n\r\n    console.log(gl.getProgramInfoLog(program));\r\n    gl.deleteProgram(program);\r\n}","import { randomInRange } from './util'\r\n\r\nexport default class Orb {\r\n    size: number;\r\n    positionX: number;\r\n    positionY: number;\r\n    colorR: number;\r\n    colorG: number;\r\n    colorB: number;\r\n    moveX: number;\r\n    moveY: number;\r\n    \r\n    lastCollision: number=0;\r\n\r\n\r\n    constructor(size: number, positionX: number, positionY: number, colorR: number, colorG: number, colorB: number, moveX: number, moveY: number) {\r\n        this.size = size;\r\n        this.positionX = positionX;\r\n        this.positionY = positionY;\r\n        this.moveX = moveX;\r\n        this.moveY = moveY;\r\n        this.colorR = colorR;\r\n        this.colorG = colorG;\r\n        this.colorB = colorB;\r\n\r\n\r\n    }\r\n\r\n    updatePosition(): void {\r\n        this.positionX += this.moveX;\r\n        this.positionY += this.moveY;\r\n    }\r\n\r\n    \r\n\r\n    reflectX(){\r\n        this.moveX*=-1;\r\n    }\r\n\r\n    reflectY(){\r\n        this.moveY*=-1;\r\n    }\r\n\r\n    deflectMovementY(min: number, max: number): void {\r\n        this.moveY = this.moveY > 0 ? randomInRange(min, max) : -1 * randomInRange(min, max)\r\n    }\r\n\r\n    deflectMovementX(min: number, max: number): void {\r\n        this.moveX = this.moveX > 0 ? randomInRange(min, max) : -1 * randomInRange(min, max)\r\n    }\r\n\r\n    shiftColor(min: number, max: number){\r\n        this.colorR = (this.colorR + randomInRange(min, max)) % 255\r\n        this.colorG = (this.colorG + randomInRange(min, max)) % 255\r\n        this.colorB = (this.colorB + randomInRange(min, max)) % 255\r\n    }\r\n}","import { frag, vert } from './shaders';\r\nimport Orb from './Orb';\r\nimport { checkCollisionRect, createShaderProgram, randomInRange } from './util';\r\n\r\ninterface minMax {\r\n    min: number;\r\n    max: number;\r\n}\r\ninterface OrbConfig {\r\n    size?: number;\r\n\r\n    posX?: number;\r\n    posY?: number;\r\n\r\n    colorR?: number;\r\n    colorG?: number;\r\n    colorB?: number;\r\n\r\n    moveX?: number;\r\n    moveY?: number;\r\n}\r\n\r\ninterface Container {\r\n    top: number,\r\n    right: number,\r\n    bottom: number,\r\n    left: number\r\n}\r\n\r\nexport class MetaBalls {\r\n    canvasRef: HTMLCanvasElement;\r\n    containerRef: HTMLElement;\r\n\r\n    orbSettings: Array<OrbConfig> | undefined | null;\r\n    orbCount: number;\r\n    orbArray: Array<Orb> = [];\r\n    onCollisionX: Function = (orb: Orb) => { orb.reflectX() };\r\n    onCollisionY: Function = (orb: Orb) => { orb.reflectY() };\r\n\r\n    gl: WebGLRenderingContext | null;\r\n    shaderProgram: WebGLProgram | null = null;\r\n    renderLoop: any;\r\n\r\n    lastContainerWidth: number;\r\n    lastContainerHeight: number;\r\n\r\n    containIn: Container = { top: 0, right: 0, bottom: 0, left: 0 };\r\n\r\n    constructor(canvasRef: HTMLCanvasElement, containerRef: HTMLElement, deflectMovement: minMax | undefined, shiftColor: minMax | undefined, orbSettings?: Array<object> | null | undefined, ) {\r\n        this.canvasRef = canvasRef;\r\n        this.orbSettings = orbSettings;\r\n        this.orbCount = orbSettings ? orbSettings.length : randomInRange(2, 10);\r\n        this.gl = canvasRef.getContext(\"webgl\");\r\n        this.lastContainerWidth = containerRef.clientWidth; /* TODO if canvasRef.size!=containerRef.size find out orbs position inside containerRef */\r\n        this.lastContainerHeight = containerRef.clientHeight;\r\n        this.containerRef = containerRef;\r\n\r\n        if (deflectMovement && shiftColor) {\r\n            this.onCollisionX = (orb: Orb) => {\r\n                orb.reflectX();\r\n                orb.deflectMovementX(deflectMovement.min, deflectMovement.max);\r\n                orb.shiftColor(shiftColor.min, shiftColor.max);\r\n            }\r\n            this.onCollisionY = (orb: Orb) => {\r\n                orb.reflectY();\r\n                orb.deflectMovementY(deflectMovement.min, deflectMovement.max);\r\n                orb.shiftColor(shiftColor.min, shiftColor.max);\r\n            }\r\n        } else if (deflectMovement) {\r\n            this.onCollisionX = (orb: Orb) => {\r\n                orb.reflectX();\r\n                orb.deflectMovementX(deflectMovement.min, deflectMovement.max);\r\n            }\r\n            this.onCollisionY = (orb: Orb) => {\r\n                orb.reflectY();\r\n                orb.deflectMovementY(deflectMovement.min, deflectMovement.max);\r\n            }\r\n\r\n        } else if (shiftColor) {\r\n            this.onCollisionX = (orb: Orb) => {\r\n                orb.reflectX();\r\n                orb.shiftColor(shiftColor.min, shiftColor.max);\r\n            }\r\n            this.onCollisionY = (orb: Orb) => {\r\n                orb.reflectY();\r\n                orb.shiftColor(shiftColor.min, shiftColor.max);\r\n            }\r\n        }\r\n\r\n    }\r\n    setCanvasDim() {\r\n        this.canvasRef.width = this.canvasRef.clientWidth;\r\n        this.canvasRef.height = this.canvasRef.clientHeight;\r\n\r\n        /* set the area where orbs spawn and bounce around */\r\n        const { offsetTop, offsetLeft, clientWidth, clientHeight } = this.containerRef;\r\n\r\n        this.containIn.bottom = this.canvasRef.clientHeight - offsetTop;  // adjust for webgl coordinate system grows bottom to top but the container position starts at top\r\n        this.containIn.right = offsetLeft + clientWidth;\r\n        this.containIn.top = this.canvasRef.clientHeight - offsetTop - clientHeight;\r\n        this.containIn.left = offsetLeft;\r\n\r\n    }\r\n\r\n    create() {\r\n        if (this.canvasRef) {\r\n            /* set renderer dimensions */\r\n            this.setCanvasDim();\r\n\r\n            this.createOrbs();\r\n\r\n            /* change fragment shaderstring with calculated arraysize */\r\n            const fragWithDynamicLength = this.setDynamicLength(frag, this.orbCount);\r\n            this.shaderProgram = createShaderProgram(this.gl, vert, fragWithDynamicLength);\r\n        } else console.log(\"no reference to the canvas was found\")\r\n    }\r\n\r\n    private createOrbs() {\r\n        this.orbArray = []\r\n\r\n        const { top, right, bottom, left } = this.containIn\r\n        /* if some orbSettings are given use them to create the orbs */\r\n        if (this.orbSettings && this.orbSettings.length > 0) {\r\n            return this.orbSettings.forEach((orbConfig, index) => {\r\n                this.orbArray[index] = new Orb(\r\n                    orbConfig.size || randomInRange(4, 60),\r\n                    (orbConfig.posX && orbConfig.posX > left && orbConfig.posX < right) ? orbConfig.posX : randomInRange(left, right),\r\n                    (orbConfig.posY && orbConfig.posY > top && orbConfig.posY < bottom) ? orbConfig.posY : randomInRange(top, bottom),\r\n                    orbConfig.colorR || randomInRange(0, 255),\r\n                    orbConfig.colorG || randomInRange(0, 255),\r\n                    orbConfig.colorB || randomInRange(0, 255),\r\n                    orbConfig.moveX || randomInRange(1, 5),\r\n                    orbConfig.moveY || randomInRange(1, 5)\r\n                )\r\n            })\r\n        }\r\n        /* else go full random */\r\n        for (let i = 0; i < this.orbCount; i++) {\r\n            this.orbArray[i] = new Orb(\r\n                randomInRange(4, 60),\r\n                randomInRange(left, right), randomInRange(top, bottom),\r\n                randomInRange(0, 255), randomInRange(0, 255), randomInRange(0, 255),\r\n                randomInRange(1, 5), randomInRange(1, 5)\r\n            )\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n    private setDynamicLength = (shaderString: string, length: number): string => {\r\n        const dataLengthSet = shaderString.replace(/<DYNAMIC_LENGTH>/, String(length * 6));\r\n        const arrSizeSet = dataLengthSet.replace(/<ORBCOUNT=0>/, `ORBCOUNT=${length}`);\r\n        return arrSizeSet;\r\n    }\r\n\r\n    private setPositionInBounds = () => {\r\n        /* TODO find orbs position inside innerContainer containerRef */\r\n        this.orbArray.forEach(e => {\r\n            /* get the relative position with the previos containersize and set it for the new containersize */\r\n            e.positionX = Math.floor(e.positionX / this.lastContainerWidth * this.containerRef.clientWidth) + this.containerRef.offsetLeft\r\n            e.positionY = Math.floor(e.positionY / this.lastContainerHeight * this.containerRef.clientHeight) + this.containerRef.offsetTop\r\n        })\r\n\r\n        /* update lastContainer size */\r\n        this.lastContainerWidth = this.canvasRef.clientWidth;\r\n        this.lastContainerHeight = this.canvasRef.clientHeight;\r\n    }\r\n\r\n    private u_orbDataFromArray = (orbArray: Array<Orb>) => {\r\n        const u_orbDataArray = [];\r\n        for (let i = 0; i < orbArray.length; i++) {\r\n            u_orbDataArray.push(orbArray[i].size);\r\n            u_orbDataArray.push(orbArray[i].positionX);\r\n            u_orbDataArray.push(orbArray[i].positionY);\r\n            u_orbDataArray.push(orbArray[i].colorR / 255); // scale colors to 0-1.0 for the shader to reduce math in loops there\r\n            u_orbDataArray.push(orbArray[i].colorG / 255);\r\n            u_orbDataArray.push(orbArray[i].colorB / 255);\r\n        }\r\n        return u_orbDataArray;\r\n    }\r\n\r\n    private updateOrbs = () => {\r\n        this.orbArray.forEach(orb => {\r\n            orb.updatePosition();\r\n            checkCollisionRect(orb, this.containIn.top, this.containIn.right, this.containIn.bottom, this.containIn.left, this.onCollisionX, this.onCollisionY);\r\n        })\r\n    }\r\n\r\n\r\n\r\n    render = () => {\r\n        if (this.gl && this.shaderProgram) {\r\n            let positionLocation = this.gl.getAttribLocation(this.shaderProgram, \"a_position\");\r\n\r\n            // Create a buffer to put three 2d clip space points in \r\n            let positionBuffer = this.gl.createBuffer();\r\n\r\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);\r\n            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([\r\n                -1, -1, // tri 1\r\n                1, -1,\r\n                -1, 1,\r\n                -1, 1, // tri 2\r\n                1, -1,\r\n                1, 1,\r\n            ]), this.gl.STATIC_DRAW);\r\n\r\n            // Tell it to use our program (pair of shaders)\r\n            this.gl.useProgram(this.shaderProgram);\r\n\r\n\r\n            // look up resolution uniform location\r\n            const uResolutionLocation = this.gl.getUniformLocation(this.shaderProgram, \"u_resolution\");\r\n\r\n            // look up orb uniform array location\r\n            const uOrbArrayLocation = this.gl.getUniformLocation(this.shaderProgram, \"u_orbData\");\r\n\r\n            const uDistModifierLocation = this.gl.getUniformLocation(this.shaderProgram, \"u_distanceModifier\");\r\n\r\n            this.gl.uniform1f(uDistModifierLocation, 5.0);\r\n            // set resolution\r\n            this.gl.uniform2fv(uResolutionLocation, [this.canvasRef.clientWidth, this.canvasRef.clientHeight]);\r\n\r\n\r\n\r\n            // Turn on the position attribute\r\n            this.gl.enableVertexAttribArray(positionLocation);\r\n\r\n            // Bind the position buffer.\r\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);\r\n\r\n\r\n            // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)\r\n            let size = 2; // 2 components per iteration\r\n            let type = this.gl.FLOAT; // the data is 32bit floats\r\n            let normalize = false; // don't normalize the data\r\n            let stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position\r\n            let offset = 0; // start at the beginning of the buffer\r\n            this.gl.vertexAttribPointer(positionLocation, size, type, normalize, stride, offset);\r\n\r\n\r\n            this.gl.viewport(0, 0, this.canvasRef.width, this.canvasRef.height);\r\n            // Clear the canvas\r\n            this.gl.clearColor(0, 0, 0, 0);\r\n            this.gl.clear(this.gl.COLOR_BUFFER_BIT);\r\n\r\n            window.onresize = () => {\r\n                if (this.gl) {\r\n                    this.setCanvasDim()\r\n\r\n                    /* recover orbs that might be off screen */\r\n                    this.setPositionInBounds()\r\n\r\n                    this.gl.uniform2fv(uResolutionLocation, [this.canvasRef.clientWidth, this.canvasRef.clientHeight]);\r\n                    this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);\r\n                }\r\n\r\n            }\r\n\r\n\r\n            const drawLoop = (gl: WebGLRenderingContext): void => {\r\n                this.updateOrbs();\r\n                gl.uniform1fv(uOrbArrayLocation,\r\n                    this.u_orbDataFromArray(this.orbArray)\r\n                )\r\n\r\n                // Draw the rectangle.\r\n                gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n\r\n\r\n\r\n                this.renderLoop = requestAnimationFrame(() => drawLoop(gl));\r\n            }\r\n            drawLoop(this.gl);\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    destroy = () => {\r\n        if (this.gl) {\r\n            cancelAnimationFrame(this.renderLoop);\r\n            this.gl.deleteProgram(this.shaderProgram);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n","export const frag: string= `\r\n\r\nprecision mediump float;\r\nconst int <ORBCOUNT=0>;\r\n\r\nuniform float u_time;\r\nuniform vec2 u_resolution;\r\n\r\nuniform float u_orbData[<DYNAMIC_LENGTH>];\r\n\r\nfloat aspectRatio=u_resolution.x / u_resolution.y;\r\n\r\nuniform float u_distanceModifier;\r\n\r\nvec3 getColSum(vec2 uv){\r\n    vec3 sumColor=vec3(0.0);\r\n\r\n    for(int i=0; i<ORBCOUNT; i++){\r\n        vec2 normBallPos=vec2(u_orbData[6*i+1], u_orbData[6*i+2]);\r\n        float ballDistance=distance(normBallPos, uv);\r\n        float multDist=ballDistance / u_distanceModifier;\r\n\r\n        float distRadius=u_orbData[6*i] / multDist;\r\n\r\n        sumColor+=vec3(distRadius*vec3(u_orbData[6*i+3], u_orbData[6*i+4], u_orbData[6*i+5]));\r\n    }\r\n    \r\n    return (sumColor / float(ORBCOUNT));\r\n\r\n}\r\n\r\nvoid main() {\r\n    gl_FragColor = vec4(getColSum(gl_FragCoord.xy), 1.0);\r\n}\r\n\r\n`\r\n\r\nexport const vert: string= `\r\nprecision mediump float;\r\nattribute vec4 a_position;\r\n\r\nvoid main() {\r\n    gl_Position = a_position;\r\n}\r\n\r\n`\r\n\r\n","import {useRef, useLayoutEffect } from 'react';\nimport * as React from 'react';\nimport { MetaBalls as MetaBallsRenderer } from './metaballsLogic';\nimport { number } from 'prop-types';\n\n\ninterface minMax{\n  min: number;\n  max: number;\n}\n\ntype propTypes = {\n  orbData?: Array<{\n    size?: number;\n\n    posX?: number;\n    posY?: number;\n\n    colorR?: number;\n    colorG?: number;\n    colorB?: number;\n\n    moveX?: number;\n    moveY?: number;\n  }>,\n  innerContainer?:  React.ReactElement;\n  children?: any;\n  childContainerFlex?: \"row\" | \"row-reverse\" | \"column\" | \"column-reverse\";\n  shiftColor?: minMax | undefined;\n  deflectMovement?: minMax | undefined;\n}\n\n\nconst defaultInnerContainer=<div className=\"metaBalls-innerContainer\" style={{width: \"100%\", height: \"100%\"}}/>\n\nconst MetaBalls: React.FC<propTypes> = ({ orbData, innerContainer=defaultInnerContainer, children, childContainerFlex, shiftColor, deflectMovement }) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  let innerRef = useRef<HTMLElement>(null);\n\n\n  useLayoutEffect(() => {\n    let metaball: MetaBallsRenderer;\n    if(canvasRef.current && innerRef.current){\n      metaball = new MetaBallsRenderer(canvasRef.current, innerRef.current, deflectMovement, shiftColor, orbData)\n      metaball.create();\n      metaball.render();\n    }\n    return () => {\n      if(metaball){\n        metaball.destroy();\n      }\n    };\n  }, [])\n\n  return (\n    <div id=\"metaballContainer\" style={{ width: \"100%\", height: \"100%\", position: \"relative\", overflow: \"hidden\"}}>\n      <canvas ref={canvasRef} style={{ width: \"100%\", height: \"100%\", position: \"absolute\", left: 0, top: 0 }} />\n      <div style={{ width: \"100%\", height: \"100%\", position: \"absolute\", left: 0, top: 0, display: \"flex\", flexDirection: childContainerFlex? childContainerFlex : \"row\"}}>\n        {React.cloneElement(innerContainer,{ref:innerRef}, null)}  {/* can be used to further contain the orbs while having some of the glow spread over the entire page*/}\n        <div style={childContainerFlex?{ height: \"100%\", flex: 1}:{ width: \"100%\", height: \"100%\", position: \"absolute\", left: 0, top: 0 }}>\n          {children} { /*YOUR FULL PAGE CONTENT GOES HERE*/}\n        </div>\n      </div>\n    </div>\n\n  );\n}\n\nexport default MetaBalls;\n","import React from 'react';\nimport MetaBalls from './metaballs'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <MetaBalls \n        /* childContainerFlex={\"row-reverse\"}  *//* container is flex you can decide the position of your content with flexdirection properties */\n        /* innerContainer={<div style={{ width: \"100%\", maxWidth: \"100%\", height: \"100%\"}} />}  */\n        shiftColor={{ min: 10, max: 60 }} \n        deflectMovement={{ min: 1, max: 7 }}\n      >\n        {<div className=\"contentDiv\">LET US BULLY YOUR GPU :)</div>}\n      </MetaBalls>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}